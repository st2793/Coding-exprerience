출처 : 프로그래머스 
피보나치 수
문제 설명
피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다.

예를들어

F(2) = F(0) + F(1) = 0 + 1 = 1
F(3) = F(1) + F(2) = 1 + 1 = 2
F(4) = F(2) + F(3) = 1 + 2 = 3
F(5) = F(3) + F(4) = 2 + 3 = 5
와 같이 이어집니다.

2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요.

제한 사항
n은 2 이상 100,000 이하인 자연수입니다.
입출력 예
n	return
3	2
5	5
입출력 예 설명
피보나치수는 0번째부터 0, 1, 1, 2, 3, 5, ... 와 같이 이어집니다.
=========================================================================


# Top-Down 그냥 재귀호출만 생각하면 오래걸림
# 실패(런타임 에러) : 과도한 재귀호출로 런타임 에러 / 실패(시간초과) : 답과 할당된 메모리 사용은 맞지만 문제애서정한 시간에 못들어옴
'''
def solution(n):

    def DFS(v):
        if v==0:
            return 0
        elif v==1:
            return 1
        else:
            return DFS(v-2)+DFS(v-1)
        
    answer = DFS(n)%1234567
    return answer
 '''   

# Top-Down 재귀호출 시 호출한 값을 저장하여 반복을 최소화하는 메모이제이션 (동적계획법)
# 71.4점 런타임 에러 : 내장함수 파라미터 줄이기..재귀함수이용줄이기.. 변수를 추가로 사용하니 용량 터진듯.
'''
def solution(n):

    def DFS(v):
        if dy[v]>0:
            return dy[v]
        elif v==0 or v==1:
            return v
        else:
            dy[v]=DFS(v-1)+DFS(v-2)
            return dy[v]
        
    dy=[0]*(n+1)    
    answer = DFS(n)%1234567
    return answer
    '''

# bottop- up 방식으로 재귀호출을 막음

def solution(n):

    res=[0]*(n+1)
    res[1]=1
    for i in range(2,n+1):
        res[i]=res[i-2]+res[i-1]
    answer=res[n]%1234567
    return answer
    
    
    
    
    => 레벨2부터는 구현보다는 효율이 중요. 오류가 뜨면 알고리즘을 바꿔야함.  
