# 2022 카카오 블라인트채용 양과늑대[Lv3]](https://programmers.co.kr/learn/courses/30/lessons/92343)


## 틀린(못푼) 이유 
* 문제풀이 시 완전탐색이 아니라 heapq라이브러를 활용하여 잘못된 구현개념으로 해결하려고 하였음.
* 완전탐색에 대한 개념을 갖추지 못했다. 완전탐색문제는 1. Brute Force 기법 2. 백트래킹 (Backtracking) 3. 순열 (Permutation) 4. 비트 마스크 (Bit Mask) 기법 중 하나로 풀어야한다는 유형화가 안되었음.

## 문제해결 아이디어

### 개념

#### 소수(Prime) 구하기
* 소수(Prime) : 1과 그 수 자신 이외의 자연수로는 나눌 수 없는 자연수이다.
* 일반적으로 자연수 k가 소수인지 구하는 방법은 아래와 같다. 2부터 k까지 for문 i를 활용하여 k가 i로 나누어떨어지는지 확인한다. 
```python
def isPrime(a):
  if(a<2):
    return False
  for i in range(2,a):
    if(a%i==0):
      return False
  return True
```
* 효율성을위해 자연수 k가 소수인지 구할때 for문을 `2부터 k`까지가 아니라 `2부터 root(k)`까지 구해도된다. 이유는 k의 약수가 반드시 존재한다고 가정한다면, 자기자신을 제외한 가장 큰 약수는 k**(1/2)가 될것이기때문에, int(k**(1/2))+1 까지만 나누어보면 소수인지 알 수 있다. 
 
```python
import math
def isPrime(a):
  if(a<2):
    return False
  # for문 낭비 최소화
  for i in range(2,int(math.sqrt(n)+1):
    if(a%i==0):
      return False
  return True
```
 
#### 에라토스테네스의 체
* 에라토스테네스의 체 : 범위에서 합성수를 지우는 방식으로 소수를 찾는 방법
* 1부터 n까지의 소수를 구하는 경우 사용한다. 즉 다수의 소수여부를 판단해야하는 경우 사용한다.  
* 1이상 100이하의 소수를 찾는 방법
```python
n=100
a = [False,False] + [True]*(n-1)
primes=[]

for i in range(2,n+1):
  if a[i]:
    primes.append(i)
    for j in range(2*i, n+1, i):
        a[j] = False
print(primes)
```
<img alt="" src="https://wikidocs.net/images/page/21638/DC-1707V1.png">

### 오류(오개념)
*  없음

### 핵심(알고리즘) 
1. n을 k진수로 변환한다. 
2. k진수로 변환한 값을 str로 형변환 후, '0'으로 split한다.
3. split한 배열값중 숫자에 해당하는경우(isdigit), 소수인지 판별후 count한다. 


## 소스코드 
import heapq
import sys
import copy
# https://dongdongfather.tistory.com/69 defautDict 활용법
#https://littlefoxdiary.tistory.com/3  힙큐 자료구조 
#https://programmers.co.kr/questions/25736  양과늑대 문제 쉬운설명 
# 완전탐색 : https://velog.io/@yesjjin99/Algorithm-%EC%99%84%EC%A0%84%ED%83%90%EC%83%89
# 완전탐색은 가능한 경우의 수를 모두 조사해서 정답을 찾는 방법으로, 무식하게 가능한 것을 다 해보겠다는 의미로 Brute Force라고도 부른다.1. 해결하고자 하는 문제의 가능한 경우의 수를 대략적으로 계산 2. 가능한 모든 방법을 다 고려 3. 실제 답을 구할 수 있는지 적용

#2-2. 완전탐색의 종류 1. Brute Force 기법 2. 백트래킹 (Backtracking) 3. 순열 (Permutation) 4. 비트 마스크 (Bit Mask!!!) 

# 2-2 2. 백트래킹 : DFS와 차이 알기 : https://velog.io/@newon-seoul/%EB%AC%B8%EA%B3%BC%EC%83%9D%EC%9D%B4-%EC%A0%81%EC%96%B4%EB%B3%B4%EB%8A%94-%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9-%EC%9E%AC%EA%B7%80%EC%99%80-DFS-%EB%A5%BC-%EA%B3%81%EB%93%A4%EC%9D%B8
# 2-2 4. 비트마스크 문제 
#https://dalseoin.tistory.com/entry/%EB%B9%84%ED%8A%B8-%EB%A7%88%EC%8A%A4%ED%81%AC-%EB%AC%B8%EC%A0%9C%EB%93%A4
##https://ssinee.tistory.com/169 풀고 지난주 문제볼것. 
sys.setrecursionlimit(10**8)

def solution(info, edges):
    answer = 0
    '''쓰지 않지만 heapq로 해결하려고 했던 발상 
    heap = []
    heapq.heappush(heap, [1,2])
    heapq.heappush(heap, [4,1])
    heapq.heappush(heap, [3,2])
    heapq.heappush(heap, [9,1])
    print(heap)
    for _ in range(4):
        print(heapq.heappop(heap))
    '''
#1. graph의 기초 틀을 만든다. 인접리스트 방식을 추천한다. graph[부모정점] 와 같이 접근하면 자식 값들을 반환하는 형태로 제작된다. info의 길이가 5인 경우 초기값 = [[], [], [], [], []] 와 같이 된다.
    graph=[[] for _ in range(len(info))]


#2. edge배열을 가지고, 그래프에 각각 데이터를 입력한다. edge첫번째 요소는, 부모정점, 두번째 요소는 자식정점이다. graph[부모정점].add(자식정점)과 같이 부모정점위치에 자식정점의 요소를 추가해준다.
    
    for parents, child in edges:
        graph[parents].append(child)
    #print(graph)
#3. 결과를 저장할 변수를 선언한다. 초기값은 0아니면 1(마음대로 해라.. 2이상은 안된다.)
    res=0
    
    


#4. dfs함수를 만든다. 함수의 인수들을 정한다. (현재 정점, 양의 수, 늑대의 수, 이동가능한 정점들) 대충 이와 같은 인수를 갖게된다. 먼저 현재 정점을 가지고, info에 정점값을 인덱스로 집어넣어 늑대인지 양인지 판단하고, 양 또는 늑대의 카운트를 하나 올린다. 그 다음에는, 결과를 저장하는 변수보다 양의 수가 더 많으면 결과변수를 현재 양의 수로 값을 업데이트한다. 만약 늑대의 수가 양의 수보다 같거나, 크면, 함수를 리턴 한다. 더 이상 수행하면 답을 구할 수 없기 때문이다. 그 다음에는 현재 이동가능한 정점들에서 현재 정점의 자식 정점들을 추가한다. 왜냐하면 현재 정점을 방문했기 때문에, 현재 정점의 자식 정점들을 탐색할 수 있는 권한이 주어졌기 때문이다. 길이 뚫린 것이다. 하하 for문으로 이동가능한 정점들을 탐색하면서, 하나씩 해당 정점을 새로운 이동가능한 정점에서 제거하여, 다음 재귀호출을 진행한다. 여기서 이동가능한 정점이 [1, 8]이 존재한다면, for문은 1하고 8을 모두 돌아보게 된다. 1을 돌아 볼 경우에는 dfs로 재귀 호출을 보낼 때, 현재 정점이 1이 되고, 이동가능한 정점이 [8]이 된다. 8을 돌게 되면, 재귀호출 시에 현재 정점이 8이 되고, 이동가능한 정점이 [1]이된다. for문을 역할은 이동가능한 정점을 하나씩 각각 순회하여, 모든 경우의 수를 탐색하는 역할이다. 해당 정점을 순회할 경우 해당 정점이 곧 현재 정점이 되고, 이미 방문을 하였기 때문에 재방문을 하면 곤란하므로 이동가능한 정점에서 자기 자신을 제거 하는 것이 된다. 단방향그래프 이므로, 그럼 같은 정점을 다시 방문하는 일을 만들지 않게 되어, 시간복잡도가 획기적으로 줄게 될 것이다.
    def DFS(nowPoint, sheep, wolf, availablePoints):
        nonlocal res
        if info[nowPoint]==0:
            sheep+=1
        else:
            wolf+=1
            #양보다 늑대의수가 많아지면 return (백트래킹)
            if wolf>=sheep:
                return
        if sheep>res:
            #print(sheep)
            res=sheep        
        
        for availablePoint in availablePoints:
            copyPoints=copy.deepcopy(availablePoints)
            copyPoints.remove(availablePoint)
            copyPoints.extend(graph[availablePoint])
            DFS(availablePoint, sheep, wolf, copyPoints)
            '''
            #틀린이유1 : 자기자신이 availablePoints에 들어가서 계속해서 중복된 dfs 처리 
            if availablePoint!=nowPoint:
                #availablePoints 추가하기
                availablePoints.extend(graph[availablePoint])
                DFS(availablePoint, sheep, wolf, availablePoints)
            '''
            '''
            #틀린이유2 : 이동가능한 정점은 리스트의 형태로 재귀호출을 보낼 경우, 리스트가 완전 복제가 일어나지 않게 되면, 독립적 변수로 취급이 되지 않아 다른 곳에서 값을 바꾸면 연쇄적으로 이어져서 값이 바뀌어 최악의 상황을 초래하게 된다. 항상 배열이나 리스트의 자료형태를
값을 독립적으로 바꾸는 작업을 수행 할 때는, 무조건 복제를 하여 독립적 리스트로써 사용하도록 주의해야한다.
            # sheep, wolf 처럼 int 값의 변동은 그냥 사용해도되지만, 리스트나 배열의 경우 주소값을 공유하므로, DFS가 실행될때마다 값이 변하게 된다.  
            availablePoints.remove(availablePoint)
            availablePoints.extend(graph[availablePoint])
            DFS(availablePoint, sheep, wolf, availablePoints)
            '''
            
            
        
    
    DFS(0,0,0,graph[0])
    

    return res
```


### 기타사항
 1. heapq를 활용한 최솟값 정렬시, 사용자가 정한 index, val 배열 값을 index에 따라 정렬하는 방법
 '''python
 #heap=[index,value]
 heap = []
    heapq.heappush(heap, [1,2])
    heapq.heappush(heap, [4,1])
    heapq.heappush(heap, [3,2])
    heapq.heappush(heap, [9,1])
    # pirnt 값은 push한 순서대로 나온다.
    print(heap)
    # heapq.heappop(힙배열)을 하면 index 최솟값정렬순으로 pop한다 
    for _ in range(4):
        print(heapq.heappop(heap))

 '''


## 참고
* [github 마크다운 : https://ffoorreeuunn.tistory.com/226](https://ffoorreeuunn.tistory.com/226)
* [참고코드1 : 소수, 에라토스테네스 체 개념](https://wikidocs.net/21638)
