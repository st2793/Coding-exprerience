# [1991번 트리순회 실버1](https://www.acmicpc.net/problem/1991)


## 틀린(못푼) 이유 
* 대표적인 트리순회 문제임을 인지하였으나, 어떻게 시도하는지 조차 몰랐음. 

## 문제해결 아이디어

### 개념
* 전위순회 : 루트 → 왼쪽자식 → 오른쪽자식
* 중위순회 : 왼쪽자식 → 루트 → 오른쪽자식
* 후위순회 : 왼쪽자식 → 오른쪽자식 → 루트 

### 핵심
* 전위/중위/후위순회는 재귀함수와 관련있는문제이다. 코드는 같지만, 출력순서를 어떻게 하느냐에따라 순회가 달라진다.
* 문제에서도 나와있듯, 항상 A가 루트노드가 된다.



### 알고리즘
 1. A,B...Y,Z를 dict()의 하나의 key로 처리한다. 
 2. 각각의 dict()의 Val 값은 [왼쪽자식, 오른쪽자식]의 값을 가지게한다. tree[A] =[A의왼쪽자식,A의오른쪽자식]
 3. 과정 1~2를 반복하며 전위/중위/후위 순회에 맞게 print 재귀함수를 시행한다. 


### 정답코드 

```python

N = int(input())
tree = {}

for _ in range(N):
    node, left, right = input().split()
    tree[node] = [left, right]


def preOrder(node):
    if node == '.':
        return

    print(node, end="")
    preOrder(tree[node][0])
    preOrder(tree[node][1])


def inOrder(node):
    if node == '.':
        return

    inOrder(tree[node][0])
    print(node, end="")
    inOrder(tree[node][1])


def postOrder(node):
    if node == '.':
        return

    postOrder(tree[node][0])
    postOrder(tree[node][1])
    print(node, end="")


preOrder('A')
print()
inOrder('A')
print()
postOrder('A')

```



## 참고

[github 마크다운](https://ffoorreeuunn.tistory.com/226)

https://velog.io/@hamfan524/%EB%B0%B1%EC%A4%80-1991%EB%B2%88-Python-%ED%8C%8C%EC%9D%B4%EC%8D%AC-Tree

