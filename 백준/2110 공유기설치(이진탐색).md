# [공유기설치 [골드5]](https://www.acmicpc.net/problem/2110)


## 틀린(못푼) 이유 
* 이진탐색으로 구현하는 문제인지에대한 감을 잡지 못하였다. 

## 문제해결 아이디어

### 개념
* 순차탐색(linear search) : 순서대로 찾는다. 완전탐색을 활용한 for문이라고 생각하면 된다.  
* 이진탐색(binary Serach) : 탐색의 범위를 절반씩 좁히며 원하는값을 찾는 기법. <b>반드시 정렬된 상태에서 실행되어야 한다.</b> O(log N)을 보장한다. 
* 파라메트릭탐색(ParaMetric Search) : 최적화 문제(문제의 상황을 만족하는 특정 변수의 최솟값, 최댓값을 구하는 문제)를 결정 문제로 바꾸어 푸는 것
 ex) 최적화 문제 : 소주를 좋아하는 나이가 가장 어린 사람 / 결정 문제 : "너 소주 좋아하니?" => 네 or 아니오
 

### 풀이전략



## 풀이

### 최초풀이(BFS를 활용한 풀이)
1. Bfs를 활용하여 res[자식노드] = 부모노드 로 설정하였다.  
```python
import sys
from collections import deque


n=int(sys.stdin.readline().rstrip())
visited=[0]*(n+1)
visited[1]=1
trees=[[] for _ in range(n+1)]
res=dict()
for _ in range(n-1):
    a,b=map(int,sys.stdin.readline().rstrip().split())
    trees[a].append(b)
    trees[b].append(a)
dq=deque()

for child in trees[1]:
    dq.append([1,child])

while dq:
    parents, child = dq.popleft()
    #print(parents,child)
    res[child]=parents
    visited[child]=1
    for childOfChild in trees[child]:
    # childOfChild!= parents 처리를 안해주면 무한루프에 빠져버린다.
        if childOfChild!= parents:
            dq.append([child,childOfChild])

#print(visited)
#print(res)
for i in range(2,n+1):
    print(res[i])
```

2. BFS를 활용하나, if문을 수정한 일반 풀이
```python
import sys
from collections import deque

n=int(sys.stdin.readline().rstrip())
visited=[0]*(n+1)
visited[1]=1
trees=[[] for _ in range(n+1)]
res=[0]*(n+1)
for _ in range(n-1):
    a,b=map(int,sys.stdin.readline().rstrip().split())
    trees[a].append(b)
    trees[b].append(a)
dq=deque()

for child in trees[1]:
    dq.append([1,child])

while dq:
    parents, child = dq.popleft()
    # res[자식노드] 값은 1이상이고, 값이 없는경우에는 부모노드가 없는것이므로 이때만 처리해주면됨. 
    if res[child]==0:
        res[child]=parents
        visited[child]=1
        for childOfChild in trees[child]:
            dq.append([child,childOfChild])
for i in range(2,n+1):
    print(res[i])
```

3. DFS를 활용한 일반 풀이
```python
import sys
#재귀함수 횟수처리하지않으면 오류뿜움
sys.setrecursionlimit(10**6)

n = int(sys.stdin.readline().rstrip())
graph = [[] for _ in range(n+1)]
visited = [False for _ in range(n+1)]
parents = [0 for _ in range(n+1)]

for i in range(n-1):
    x,y = map(int, sys.stdin.readline().rstrip().split())
    graph[x].append(y)
    graph[y].append(x)

def dfs(cur):
    visited[cur] = True
    for next in graph[cur]:
        if visited[next] == False:
            parents[next] = cur
            dfs(next)
dfs(1)
for i in range(2, n+1):
    print(parents[i])
```



## 참고
* [github 마크다운 : https://ffoorreeuunn.tistory.com/226](https://ffoorreeuunn.tistory.com/226)
* [이진탐색](https://heytech.tistory.com/64)
* [파라메트릭서치](https://sarah950716.tistory.com/16)
