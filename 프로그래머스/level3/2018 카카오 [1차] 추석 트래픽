링크 : https://programmers.co.kr/learn/courses/30/lessons/17676

1. 문제유형 : 구현력
구현력문제는 풀이를 떠올리기 어려운 문제가 아니라, 생각한대로 코드를 옮기는데 문제가 있다. 이문제의 경우 이틀에 걸쳐 풀었다.
이유는 범위지정 오류와 float + float 간의 오차가 발생한다는 것을 인지하지 못하였기떄문이다. 



2. 개념(실수값의 오차)  출처 : https://dojang.io/mod/page/view.php?id=2466
매번헤매던 케이스이니 정리를 잘해두자. 
파이썬에서 0.1+0.2는 얼마일까
>>> 0.1 + 0.2
0.30000000000000004
=> 컴퓨터에서는 숫자를 비트로 표현하는데 실수는 유한개의 비트로 정확하게 표현할 수가 없다.
. 이렇게 실수를 근삿값으로 표현하면서 발생하는 문제를 부동소수점 반올림 오차(rounding error)라고 한다.
따라서 다음과같다. 
>>> 0.1 + 0.2 == 0.3
=> False

>>> float(0.1 + 0.2) == 0.3
=> False


그렇다면 어떻게 부동소숫점 또는 순환소수점의 산수계산간의 차이를 없앨까? 방법은 불가능하다.
그저 다음 세가지 방법중 문제에 맞게 활용할 뿐이다.

2.1.) Decimal으로 정확한 자릿수 표현하기(부동소수점만 표현가능)
>>> from decimal import Decimal
>>> Decimal('0.1') + Decimal('0.2')
=> Decimal('0.3')

2.2.) Fraction으로 분수 표현하기(부동소수,순환소수 표현가능)
>>> from fractions import Fraction
>>> Fraction('10/3')    # 10을 3으로 나누면 순환소수 3.33333...이지만 분수 3분의 10으로 표현
 => Fraction(10, 3)

2.3.) 부동소수의 산수간 자릿수가 n번째로 고정된경우=> round 함수활용하여 근삿값 표현 
 * 소수첫째자리 부동소수간의 합을 표현하고싶은경우
>> 0.1 +0.2
=> 0.30000000000000004
>> round(0.1+0.2,2)
=> 0.3

다음과 같이 소수첫째자리 부동소수 변수간의 합만 구한다고 한다면 오차는 저~~~멀리있는 0.kxxxxxxxxxxxxxn 언저리쯤되니까 round를 활용할 수 있다. 
이번문제에서 활용할예정!! 아무리봐도 Decimal과 Fraction은 boolean으로 밖에 쓸수가 없는것같다.. 


3. 코드리뷰(구현련문제라 코드가 길어  기존과 달리, 잘못푼 부분을 짚어가며 정리하겠다.)

# 구현문제. 알고리즘보다 복잡문제해결능력위한 구현능력중요
def solution(lines):
    graphs=[]
    points=[]
    #1. 문자열 자르기 2019-09-015 불필요하니 hh:mm:s1s2.s3s4s5와 0.x1x2x3만 파싱
    for line in lines:
        line=line.split(' ')[1:]
        # S:응답완료시간, T:처리시간
        S=line[0].split(':')
        hh=int(S[0])
        mm=int(S[1])
        ss=float(S[2])
        #ss=int(ss*1000)/1000
        
        # 오답1: 부동소수점 연산에대한 개념이 부족하여헤맸다. 
        #T=int(T*1000)/1000
        #처음에 부동소수점 오차가나와서 당황해서 이런식으로 풀었는데, 옳지못한 풀이다. 왜냐하면 이와같은 접근은 1000을 곱하고 int화하기때문에 소숫점을 잘라버리기떄문에 '반올림'이 아닌 '버림'이기떄문에 혹시모를오차가 생길 수 있다. 
        #부동소수점합 round를 활용하자. github 정리 참고
        T=round(float(line[1][:-1])-0.001,3)
        
        
        #2.[[시작1, 끝1], [시작2,끝2]....]로 파싱. 0.001s<=T<=3.000s
        #끝 :  hh:mm:s1s2.s1s2s3
        ep=[hh,mm,ss]
        # 오답2: hh:mm:s1s2.s3s4s5 처리방안 오류 
        # 최초생각 : 문자열을 : 으로 쪼갠뒤 각각의 숫자를 문자열로 인식하려고했다. 이렇게하면, 연산 시 단위를 76분처럼 초과하는경우의수를 각각처리해줘야한다. 총 8개(hh, mm,s1,s2,s3,s4,s5,s6)의 경우의 수가 생기는데, 자릿수 올려줄떄마다 문자와 숫자 타입을 왔다갔다하는 번거로움과 hh,mm은 단위가 60인데비해 s1s2는 합쳐서 60단위, s3~s6는 10단위라는 아주 괴상한 경우가 생긴다. 이런식으로 풀려면 아래와 같은 괴상한 수식이 생기고 예외처리해야한다. 
        #  시작 :  hh:mm:(s1s2.s3s4s5(S)-x1.x2x3x4(T)+0.001)
        
        # 옳은풀이 : 각각의 시분초단위를 초로 환산하자
        # ss-T+0.001,3 반올림처리
        sp=[hh,mm,ss-T]
        #sp,ep 초단위로 변경
        ep=hh*3600+mm*60+ss
        sp=round(ep-T,3)
        #print(sp)
        #print('초단위sp',sp)
        #print('초단위ep',ep)
        graphs.append([sp,ep])
        points.append(ep)
        points.append(sp)
    #points 정렬    
    points.sort()
   # print("포인트",points)
    #graphs 시작점 기준 정렬 
    graphs.sort()
    #print("그래프", graphs)
    answer = 0
    for point in points:
        cnt=0
        point2=round(point+1,3)
        #각포인트 위치마다 최대치 합 확인
        for graph in graphs:
            sp,ep=graph
            #print(sp,ep)
            # 포인트구간은 point(p1)<=포인트구간<poin+1(p2)
            # 그래프 그려서 경우의수 나눠
#            if (point<sp and point2>sp) or point==sp or (sp<point<ep) or (ep==point):
            # if (sp<=point2<=ep) 아니라 if (sp<point2<=ep) point 이상 point2 
           # if (sp<point2<=ep) or (sp<=point<=ep) or (point<=sp and point2>=ep): 에서 (point<=sp and point2>=ep) 범위를 잘못나눔
            if (sp<point2<=ep) or (sp<=point<=ep) or (point==sp) or (point==ep) or (point<sp and point2>sp):
                cnt+=1
                #print('cnt:',cnt,'point1:',point,'point2:',point+1,'graph',graph)
            #break가 틀린포인트였음/....
            #elif point>sp:
             #   break
        answer=max(answer,cnt)

    
    return answer
